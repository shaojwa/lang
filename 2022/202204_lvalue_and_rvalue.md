https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers

#### 什么是值类别
这是C++11引入的一个概念，包括左值，纯右值，xvalue，通用左值，右值。这个概念非常复杂，分类很多。

#### 什么是左值（lvalue）
三种基本类别之一，我们可以简单这么记忆，在C++11之前，可以放在等号左边的就是做左值，能放左边的也都能取地址。

### 什么是纯右值（prvalue）
三种基本类别之一。

#### 什么是临终值（xvalue）
三种基本类别之一，x的意思是expiring，表示将要过期，不过喜欢把这种类型称为`可重用值`，因为这种类型的值就是表示这个对象可以重用。

C++11中定义了集中情况的expression是xvalue的:
1. 比如返回值为对象rvalue-reference的函数，比如std::move()。
2. 右值数组a的某个元素，即`a[n]`。
3. 右值元素a的非静态非引用成员m，即`a.m`
5. 右值元素a的成员指针mp的解引用，即`a.*mp`。
6. 右值引用static_cast。
7. 特性的b和c场景下的`a?b:c`三元运算。
8. 一个指定为临时对象的表达式。

我们可以先记住这个情况，然后去理解lvalue和prvalue。

## 基于以上三种类别，我们有两种混合类别glvalue和rvalue。

#### 什么是通用左值
但是能放在赋值运算左边这个属性，在C++11中不够，我们需要明确，这个表达式能否确定对象或者函数的identity。
在有变量名的表达式，是左值，当然也能determine一个对象的identiry，所以左值也属于通用左值。

#### 什么是右值
有的表达式不能determine一个对象的identity。比如42，比如a++, 我们无法通过这个表达式确定这个对象的identity。
我们无法用这个表达式在再次访问到这个对象。我们能用42再次放到的一个对象么？不能，我们能用a++这个表达式再次访问到一个对象么？不能
因为a++返回的是一个临时的对象，返回的对象已经和a没有关系，所以a++和++a是有区别的。
所以，右值只能得到一个对象的值，但是我们却无法得到这个对象的identity。也许是根本就没这个object，也许是得不到这个object的identity。

## 一些问题
#### 一个表达式的左值或者右值属性和这个表达式的类型无关
```
the lvalueness or rvalueness of an expression is independent of its type. 
```
比如：
```
Widget&& var1 = makeWidget()
```
表达式的类别是左值，但是这个表达式的类型是右值引用。var是对右值的引用，但他自己不是右值。var本身是左值还是右值，和他是对右值的引用还是对左值的引用没有关系。
