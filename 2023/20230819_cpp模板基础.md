#### 重载和模板的目的
两者有点类似，同样类型的代码，根据参数类型和上下文，来执行实际上不同的代码。
```
auto b = begin(c);
```
`begin()`干的事，取决于c的类型。`begin()`可以调用std中的`begin()`，也可能是`begin(T (&array)[])`模板函数，还可能是用户自己定义的以c类型为参数的函数函数。

#### 模板的目的
一套代码，能处理不同的类型。

#### 模板参数
模板参数可以是类型模板参数，还有非类型的模板参数（比如某种类型的值，比如整数类型的值，比如bitset中的N），


#### 模板的类型
函数模板，类模板，变量模板。

#### 实例化
包括隐式实例化，就是在直接用模板函数的时候，最常见的类型。另一种是显式实例化，这种方式很少用，实例化了一个函数，但是没有调用，比如：
```
template int my_gcd(int a, int b);
```
只有在，需要实例化的类型的种类比较确定的情况下，才会显示实例化。

#### weak symbols
弱符号最后是可以合并成一个的。

#### 显示特化
针对模板函数的某一种参数类型，我们有一个具体的实现，和通用的实现不同，所以特化是需要写实现代码的，是针对某一种类型的特定的实现，所以叫踏特化。
函数的特化是一种具体的实现，不是通用模板函数的实例化，两者都是实现，只是特化更加特殊。

#### 偏特化，全特化
偏特化，就是对模板模板参数进行确定，或者约束。全特化就是对所有模板参数进行确定。

#### 函数模板（C++98） 类模板（C++98） 变量模板（C++14）
函数模板没有偏的话，只有全特化，类模板变量模板有偏特化，如果函数想达到类似偏特化的功能，通常用函数重载来达到。
或者通过类的函数对象来达到偏特化。

#### 高级技术
1. 类函数对象的偏特化。
2. 用模板作为模板的参数。
