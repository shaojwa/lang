#### 第三讲 右值和移动究竟解决了什么问题？
1. 左右值分类。
1. 值绑定到参数。
1. volatile (想象成variable) 和const相对。1
1. 可以用const volatile 来修饰左值引用或者右值引用，或者修饰左值，但是不会修饰右值。
1. 引入一种额外的引用类型当然增加了语言的复杂性，但也带来了很多优化的可能性。
1. noexcept 修饰符。
1. 右值引用的变量可以是一个左值，那右值引用的可以不是一个变量么？
1. std::move() 改变了一个变量的值类别，注意，不是指类型。就是变成一个右值引用。
1. 对于指针，我们一般用值传递，并不关心是左值还是右值。
1. 它的作用是把一个左值引用强制转换成一个右值引用，而并不改变其内容。
1. “值类别”（value category）和“值类型”（value type）完全不同，一个是说左右之，一个是引用还是非引用。
1. C++ 的规则是：一个临时对象会在包含这个临时对象的完整表达式估值完成后、按生成顺序的逆序被销毁。
1. 如果一个 prvalue 被绑定到一个引用上，它的生命周期则会延长到跟这个引用变量一样长。
1. unique_ptr只有移动构造，没有拷贝构造。
1. named return value optimization，NRVO
